#!/bin/bash
VERSION="1.0-beta"
dws="$(basename "$0")"
name_here="dws-here"
file_beacon=".dws-beacon"


function pause() {
    local p="$1"
    test -z "$p" && local p="... "
    read -p "$p"
}


function make_new_dir_dws() {
    dir_dws="$HOME/.dws-home"
    while [ -d "$dir_dws" ]; do
        dir_dws="${dir_dws}e"
    done
    test -n "$1" && echo "$1" 1>&2
    while true; do
        read -ep "Where should we put the DWS work files? [$dir_dws] "
        if [ -n "$REPLY" ]; then
            dir_dws="$(realpath $(eval "echo $REPLY"))"
        fi
        if [ "$(echo $dir_dws | head -c 1)" = '-' ]; then
            echo "Looking for shenanigans, eh? Nuts to you."
            exit 11
        elif [ -d "$dir_dws" ]; then
            read -ep "Directory $dir_dws already exists. It would be smarter to create a new directory. Use it nonetheless? [y/N] "
            if echo "$REPLY" | xargs | head -c 1 | egrep -qi '^y'; then
                echo "You're the boss!" 1>&2
                break
            fi
        else
            mkdir -p "$dir_dws" && break
            echo "Oops, had a problem creating that directory. Let's try this again." 1>&2
        fi
    done
}


function have_dir_dws() {
    dir_dws="$(find $HOME -name "$name_here" 2>/dev/null | head -n 1 | xargs -n 1 dirname 2>/dev/null)"
    if [ -z "$dir_dws" ]; then
        make_new_dir_dws "Hello! It seems you have never used a Dumb Work Space on this machine before."
    fi
}


function Git() {
    eval "git -C \"$dir_repo\" $@"
}

function have_repo_git() {
    dir_repo="$dir_dws/parentship"
    if [ ! -d "$dir_repo/.git" ]; then
        while true; do
            read -ep "Enter the clone URL to the remote (e.g. Github) repository to use with DWS: "
            local url=$(echo $REPLY | xargs)
            if [ -n "$url" ]; then
                if git clone "$url" "$dir_repo"; then
                    echo "Repository $dir_repo is your parentship." 1>&2
                    break
                fi
                echo "Cloning your Github repository failed. Let's try again." 1>&2
            else
                echo "Oh come on. Let's try again." 1>&2
            fi
        done
    fi
    while ! Git config user.name >/dev/null; do
        read -ep "Input the name as which you would commit your work: "
        Git config user.name "'$(echo "$REPLY" | xargs)'"
    done
    while ! Git config user.email >/dev/null; do
        read -ep "Input the address which which you would commit your work: "
        Git config user.email "'$(echo "$REPLY" | xargs)'"
    done
    if Git config commit.gpgsign | grep -q true && ! Git config user.signingKey; then
        echo "I disable GPG signing of the parentship commits, since I'm not 100% sure which GPG key you would use to sign. You may re-enable it as you see fit, at your own convenience." 1>&2
        Git config commit.gpgsign false
    fi
    if ! Git log -1 2>&1 >/dev/null; then
        echo "The parentship repo is empty. I will add an empty commit." 1>&2
        Git commit --allow-empty "--message=\"Root commit\"" 1>&2 || exit
    fi
    if Git branch --verbose | grep -qv '^\* main'; then
        Git branch -M main || exit
    fi
    if Git branch --verbose | grep '^\* main' | grep -q '\[gone\]'; then
        Git push --set-upstream origin main 1>&2
    fi
}


function list_files() {
    find "$dir_repo" | sed -Ee "s!$dir_repo/?!!" | awk '$0 && !/^.git\/?/'
}


function is_workstation_name_used() {
    list_files | awk -F/ '{print $1}' | sort | uniq | grep -q "^$1$"
}


function identify_machine() {
    path_here="$dir_dws/$name_here"
    if [ -f "$path_here" ]; then
        here="$(cat "$path_here")"
    else
        here="$(hostname -s)"
        while true; do
            read -ep "Input unique workstation name $(test -n "$here" && echo [$here]) "
            local answer=$(echo $REPLY | xargs)
            test -n "$answer" && here="$answer"
            if [ -z "$here" ]; then
                echo "Oh come on. Let's try this again." 1>&2
            elif echo "$here" | egrep -qv '^[a-zA-Z][-_a-z0-9.]*$'; then
                echo "Stick to names composed of letters, digits and dashes, and that starts with a letter. Let's try again." 1>&2
            elif is_workstation_name_used "$here"; then
                echo "The name [$here] is already used on another one of your workstations. Let's try again." 1>&2
            else
                echo "$here" >"$path_here"
                break
            fi
        done
    fi
}


function init() {
    have_dir_dws
    have_repo_git
    identify_machine
}


function die_list() {
    cat 1>&2 <<USAGE
Usage: $dws list [-n]
       $dws list -h

Description: list all files stored in your Dumb Work Space. Each file comes as
a path-like entry, starting with the workstation name, followed by the space
name, and then the file itself. As all files are stored locally, they can be
stat'ed, looked up and otherwise manipulated. Any serious work, however, is
best performed by cloning other workstations' spaces to your current, using
command $dws clone.

Options:

    -n  Skip updating the parentship from the remote repository.
    -h  Print out this help and exit.
USAGE
    exit $1
}


function update_parentship() {
    Git checkout main 1>&2 && Git pull origin main 1>&2 || exit
}


function list() {
    local skip_update=""
    while getopts "hn" arg; do
        case "$arg" in
            n)  local skip_updates="yes" ;;
            h)  die_list 0 ;;
            *)  die_list 1 ;;
        esac
    done

    init
    test -z "$skip_updates" && update_parentship
    list_files
}


function is_nickname_used() {
    list_files | awk -F/ -v "host=$here" -v "nickname=$1" '($1==host && $2==nickname){exit 0} END{exit 1}'
}


function choose_nickname() {
    if [ -f "$file_beacon" ]; then
        local nickname_from_beacon="$(cat "$file_beacon")"
        if [ -n "$nickname" ]; then
            cat 1>&2 <<NICKNAME
You propose using space nickname [$nickname], but this space has previously
been synchronized under the nickname [$nickname_from_beacon].
NICKNAME
            read -ep "Should I replace $nickname_from_beacon with $nickname? [yN] "
            if echo "$REPLY" | xargs | egrep -qi '^y'; then
                cat 1>&2 <<RENAME
Ok, this space is now renamed $nickname. Remark that the parentship will still
store the files sent there so far under nickname $nickname_from_beacon in
addition to new ones. Use command $dws rm to get rid of those.
RENAME
            else
                echo "No worries, we keep this space named $nickname_from_beacon." 1>&2
                nickname="$nickname_from_beacon"
            fi
        else
            nickname="$nickname_from_beacon"
        fi
    fi

    test -z "$nickname" && nickname="$(basename "$(pwd)")"
    while true; do
        if [ -z "$nickname" ]; then
            echo "You can't use an empty string to nickname a work directory. Let's try again." 1>&2
        elif echo "$nickname" | egrep -qv '[a-zA-Z0-9_.][-a-zA-Z0-9_.]*'; then
            echo "Nickname this work directory using only letters, numbers, dashes, underscores and periods. The nickname $nickname does not work." 1>&2
        elif is_nickname_used "$nickname"; then
            read -ep "Work directory nickname $nickname is already being used on this workstation. If you insist on using it for this work directory, you will overwrite the parentship's store. That content will still be present in the parentship's Git history, should you need again. Do we proceed? [yN] "
            if echo "$REPLY" | xargs | egrep -qi '^y'; then
                echo "As always, you're the boss!" 1>&2
                break
            fi
        else
            break
        fi
        read -ep "Input nickname: "
        nickname="$(echo "$REPLY" | xargs)"
    done

    echo "$nickname" >"$file_beacon"
}


function die_clone() {
    cat 1>&2 <<USAGE
Usage: $dws clone workstation/space [directory]
       $dws
USAGE
    exit $1
}


function clone() {
    echo "Don't know how to clone!"
    exit 42
}


function remove() {
    echo "Don't know how to remove!"
    exit 42
}


function die_sync() {
    cat 1>&2 <<USAGE
Usage: $dws sync [-e] [-m MESSAGE] [--] [nickname]
       $dws sync -h

Synchronizes the current space to the parentship. This is done by copying the
files to the local repository, committing that to an ad hoc branch, then
merging and pushing that on the parentship's main branch. By default, a
boilerplate commit message is associated to the files. You can edit this commit
message, or change it through the command line. In the latter two cases, the
commit is completed and pushed even if the files of this work directory match
exactly those at the parentship: if one insists on committing, $dws is not going
to oppose.

Options:

    -e         Edits the message before completing the commit and sync.
    -m MESSAGE Specifies a message on the command line.
    -h         Print out this help and exit.
    nickname   By default, a space's nickname is the name of the directory.
               You may, however, choose a different nickname if you prefer.
               If $dws is invoked without command, you may specify the nickname
               by separating it from other arguments with --. Remark that no
               option can appear beyond the nickname or --.

If both the -e and -m options are specified, the message provided is the
one opened in the editor through Git.
USAGE
    exit $1
}


function sync() {
    local allow_empty_commit=""
    local do_edit=""
    local message_commit=""
    while getopts "hm:e" arg; do
        case "$arg" in
            e)  local do_edit="--edit"
                local allow_empty_commit="--allow-empty"
                ;;
            m)  local message_commit="$OPTARG"
                local allow_empty_commit="--allow-empty"
                ;;
            h)  die_sync 0 ;;
            *)  die_sync 1 ;;
        esac
    done
    shift $((OPTIND - 1))
    test "$1" = "--" && shift
    nickname="$1"
    test -z "$message_commit" && local message_commit="Sync $nickname"

    init

    if [ "$(pwd)" = "$HOME" ]; then
        cat 1>&2 <<AREYOUSURE
You are proposing here to turn your whole home directory into a space and
synchronize it over multiple workstations using a remote Git repository.
One's home directory often contains secrets, such as private cryptographic
keys, sensitive documents, personal information, and so on. If your parentship
is hosted on a public service such as Github, Gitlab, Bitbucket, Sourcehut,
etc., you may end up putting this highly sensitive data where it can be
observed by others (if your parentship is a public repository) or stolen
through cyberattacks against the service. Moreover, if you go ahead and do it,
undoing this may be complicated, and you might have no possibility to strictly
ensure your data is effectively scrubbed off the service.

AREYOUSURE
        read -ep "Are you sure you want to proceed? [yN] "
        if echo "$REPLY" | xargs | grep -qi '^y'; then
            echo "Alright, you're the boss!" 1>&2
        else
            echo "In my humble opinion, you made a wise choice." 1>&2
            exit 0
        fi
    fi

    if [ ! -f "$file_beacon" ]; then
        local size_space=$(du -m --summarize | awk 'BEGIN{s=0} {s += $1} END{print s}')
        if [ "$size_space" -gt 10 ]; then
            for unit in MB GB TB PB infinibytes; do
                test "$size_space" -le 1024 && break
                local size_space=$((size_space >> 10))
            done
            cat 1>&2 <<LARGE
This directory contains a large volume of data, about $size_space $unit. Large files,
especially binary files, are not handled efficiently by Git. Synchronizing
this space may thus be cumbersome, and you might hit storage restrictions from
the hosting service associated to your parentship.

LARGE
            read -ep "Proceed nonetheless? [Yn] "
            if echo "$REPLY" | xargs | grep -qi '^n'; then
                echo "Let's drop this then." 1>&2
                exit 0
            else
                echo "You're the boss!" 1>&2
            fi
        fi
    fi

    choose_nickname
    local branch_sync="sync_$nickname"

    while true; do
        update_parentship
        if Git branch | grep -qv "^$branch_sync$"; then
            Git checkout -b "$branch_sync" 1>&2 || exit
            trap "Git checkout --force main 1>&2 && Git branch --delete --force \"$branch_sync\" 1>&2" EXIT
            local dir_work="$dir_repo/$here/$nickname"
            rm -rf "$dir_work" \
                && mkdir -p "$(dirname "$dir_work")" \
                && cp -R . "$dir_work" \
                && rm -f "$dir_work/$file_beacon" \
                || exit
            local x=0
            if [ -n "$(Git status --short)" -o -n "$allow_empty_commit" ]; then
                Git add --all 1>&2 && Git commit "--message=\"$message_commit\"" $do_edit $allow_empty_commit 1>&2
                local x=$?
            else
                echo "This work directory is already up to date at the parentship." 1>&2
                break
            fi
            Git checkout --force main 1>&2
            test $x != 0 && exit $x
        fi

        (
            Git checkout -b to_push 1>&2 || exit
            trap "Git checkout --force main && Git merge to_push ; Git branch --delete --force to_push" EXIT
            Git merge "$branch_sync" 1>&2 || exit
            Git push --porcelain origin to_push:main 2>&1 \
                | awk -F'\t' '!/^remote:/{print > "/dev/stderr"}
                              ($1 == "!" && /to_push/ && /main/){exit 123}'
        ) && break
        local x=$?

        if [ "$x" = "123" ]; then
            cat 1>&2 <<UPLOAD
The upload of the $nickname work directory failed. This may be because the
parentship's main branch has been modified while preparing this update.
I will wait a few seconds and try again.
UPLOAD
            sleep 5
        else
            exit "$x"
        fi
    done
}


function here() {
    init
    echo $here
}


function ship() {
    init
    echo $dir_repo
}


function die_generic() {
    cat 1>&2 <<USAGE
Usage: $dws command [OPTIONS] ARGS
       $dws -h --> Print out this help and exit.
       $dws -v --> Print out version information and exit.

Description: dws is the Dumb Work Space. You use it to carry your work across
the various workstations you have to use. Do this by defining _spaces_ on each
workstation, which are directories recursively saved to the _parentship_. This
is a Git repository that is kept in sync with the spaces on every workstation,
over any remote Git server you prefer.

Commands:

    sync         Synchronize the current space with the parentship.
    list, ls     List all files present on the parentship.
    clone        Clone a space from another workstation.
    remove, rm   Remove a local work directory.
    here         Report the name of this workstation as you set it up.
    ship         Report the parentship directory, so you may fiddle with it
                 and re-arrange its synchronization at your convenience.

Without any command, dws behaves as though sync was invoked.

Requirement: having a remote Git repository (on Github, Gitlab, Bitbucket,
Sourcehut, or any SSH server you care about) that you can use as parentship.
USAGE
    exit $1
}


# What do we do?
if echo "$1" | egrep -q '^([a-z]|-[hv])' ; then
    cmd="$1"
    shift
    case "$cmd" in
        ls)        list "${@}" ;;
        list)      list "${@}" ;;
        clone)     clone "${@}" ;;
        rm)        remove "${@}" ;;
        remove)    remove "${@}" ;;
        del)       remove "${@}" ;;
        delete)    remove "${@}" ;;
        sync)      sync "${@}" ;;
        here)      here "${@}" ;;
        ship)      ship "${@}" ;;
        -h)        die_generic 0 ;;
        -v)        echo $VERSION ;;
        *)
            echo "Unknown command: [$cmd]" 1>&2
            die_generic 1
            ;;
    esac
else
    sync "${@}"
fi
