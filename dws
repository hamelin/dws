#!/bin/bash
VERSION="1.0-beta"
name_here="dws-here"
file_beacon=".dws-beacon"


function make_new_dir_dws() {
    dir_dws="$HOME/.dws-home"
    while [ -d "$dir_dws" ]; do
        dir_dws="${dir_dws}e"
    done
    test -n "$1" && echo "$1" 1>&2
    while true; do
        read -ep "Where should we put the DWS work files? [$dir_dws] "
        if [ -n "$REPLY" ]; then
            dir_dws="$(realpath $REPLY | xargs)"
        fi
        if [ "$(echo $dir_dws | head -c 1)" = '-' ]; then
            echo "Looking for shenanigans, eh? Nuts to you."
            exit 11
        elif [ -d "$dir_dws" ]; then
            read -ep "Directory $dir_dws already exists. It would be smarter to create a new directory. Use it nonetheless? [y/N] "
            if echo "$REPLY" | xargs | head -c 1 | egrep -qi '^y'; then
                echo "You're the boss!" 1>&2
                break
            fi
        else
            mkdir -p "$dir_dws" && break
            echo "Oops, had a problem creating that directory. Let's try this again." 1>&2
        fi
    done
}


function have_dir_dws() {
    dir_dws="$(find $HOME -name "$name_here" 2>/dev/null | head -n 1 | xargs -n 1 dirname 2>/dev/null)"
    if [ -z "$dir_dws" ]; then
        make_new_dir_dws "Hello! It seems you have never used a Dumb Work Space on this machine before."
    fi
}


function Git() {
    eval "git -C \"$dir_repo\" $@"
}

function have_repo_git() {
    dir_repo="$dir_dws/parentship"
    if [ ! -d "$dir_repo/.git" ]; then
        while true; do
            read -ep "Enter the clone URL to the remote (e.g. Github) repository to use with DWS: "
            local url=$(echo $REPLY | xargs)
            if [ -n "$url" ]; then
                if git clone "$url" "$dir_repo"; then
                    echo "Repository $dir_repo is your parentship." 1>&2
                    break
                fi
                echo "Cloning your Github repository failed. Let's try again." 1>&2
            else
                echo "Oh come on. Let's try again." 1>&2
            fi
        done
    fi
    while ! Git config user.name >/dev/null; do
        read -ep "Input the name as which you would commit your work: "
        Git config user.name "'$(echo "$REPLY" | xargs)'"
    done
    while ! Git config user.email >/dev/null; do
        read -ep "Input the address which which you would commit your work: "
        Git config user.email "'$(echo "$REPLY" | xargs)'"
    done
    if Git config commit.gpgsign | grep -q true && ! Git config user.signingKey; then
        echo "I disable GPG signing of the parentship commits, since I'm not 100% sure which GPG key you would use to sign. You may re-enable it as you see fit, at your own convenience." 1>&2
        Git config commit.gpgsign false
    fi
    if ! Git log -1 2>&1 >/dev/null; then
        echo "The parentship repo is empty. I will add an empty commit." 1>&2
        Git commit --allow-empty "--message=\"Root commit\"" 1>&2 || exit
    fi
    if Git branch --verbose | grep -qv '^\* main'; then
        Git branch -M main || exit
    fi
    if Git branch --verbose | grep '^\* main' | grep -q '\[gone\]'; then
        Git push --set-upstream origin main:main 1>&2
    fi
}


function list_files() {
    find "$dir_repo" | sed -Ee "s!$dir_repo/?!!" | awk '$0 && !/^.git\/?/'
}


function is_workstation_name_used() {
    list_files | awk -F/ '{print $1}' | sort | uniq | grep -q "^$1$"
}


function identify_machine() {
    path_here="$dir_dws/$name_here"
    if [ -f "$path_here" ]; then
        here="$(cat "$path_here")"
    else
        here="$(hostname -s)"
        while true; do
            read -ep "Input unique workstation name $(test -n "$here" && echo [$here]) "
            local answer=$(echo $REPLY | xargs)
            test -n "$answer" && here="$answer"
            if [ -z "$here" ]; then
                echo "Oh come on. Let's try this again." 1>&2
            elif echo "$here" | egrep -qv '^[a-zA-Z][-_a-z0-9.]*$'; then
                echo "Stick to names composed of letters, digits and dashes, and that starts with a letter. Let's try again." 1>&2
            elif is_workstation_name_used "$here"; then
                echo "The name [$here] is already used on another one of your workstations. Let's try again." 1>&2
            else
                echo "$here" >"$path_here"
                break
            fi
        done
    fi
}


function init() {
    have_dir_dws
    have_repo_git
    identify_machine
}


function add_or_sync() {
    if [ -f "$file_beacon" ]; then
        sync
    else
        add
    fi
}


function list() {
    echo "Don't know how to list!"
    exit 42
}


function die_add() {
    cat 1>&2 <<USAGE
Usage: $0 add [nickname]
       $0 -h

Adds a work directory to the workspace under a chosen nickname. By default,
the nickname corresponds to the directory's own name. $0 will help you choose
a unique name. A work directory can be added only under a single nickname.

After the work directory has been added to the workspace, it is synchronized
for the first time.

Options:

    -h  Print out this help.
USAGE
    exit $1
}


function add() {
    if [ -f "$file_beacon" ]; then
        echo "Directory already added as $(cat "$file_beacon") on this workstation."
        exit 2
    fi

    init

    while getopts 'h' arg; do
        case "$arg" in
            h) die_add 0 ;;
            *) die_add 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    name_dir="$1"
    test -z "$name_dir" && name_dir="$(basename "$(pwd)")"
    while true; do
        if [ -z "$name_dir" ]; then
            echo "You can't use an empty string to nickname a work directory. Let's try again." 1>&2
        elif echo "$name_dir" | egrep -qv '[a-zA-Z0-9_.][-a-zA-Z0-9_.]*'; then
            echo "Nickname this work directory using only letters, numbers, dashes, underscores and periods. The nickname $name_dir does not work." 1>&2
        elif is_name_dir_used "$name_dir"; then
            echo "Work directory nickname $name_dir is already being used on this workstation. Let's try again." 1>&2
        else
            echo "$name_dir" >"$file_beacon"
            break
        fi
        read -ep "Input nickname: "
        name_dir="$(echo "$REPLY" | xargs)"
    done
    sync
}


function clone() {
    echo "Don't know how to clone!"
    exit 42
}


function remove() {
    echo "Don't know how to remove!"
    exit 42
}


function die_sync() {
    cat 1>&2 <<USAGE
Usage: $0 sync [-e] [-m MESSAGE]
       $0 -h

Synchronizes the current space to the parentship. This is done by copying the
files to the local repository, committing that to an ad hoc branch, then
merging and pushing that on the parentship's main branch. By default, a
boilerplate commit message is associated to the files. You can edit this commit
message, or change it through the command line. In the latter two cases, the
commit is completed and pushed even if the files of this work directory match
exactly those at the parentship: if one insists on committing, $0 is not going
to oppose.

Options:

    -e         Edits the message before completing the commit and sync.
    -m MESSAGE Specifies a message on the command line.
    -h         Print out this help.

If both the -e and -m options are specified, the message provided is the
one opened in the editor through Git.
USAGE
    exit $1
}


function sync() {
    if [ ! -f "$file_beacon" ]; then
        echo "This work directory is not identified for storage in the mothership. Run $0 add first."
        exit 3
    fi
    local nickname="$(cat "$file_beacon")" || exit
    local branch_sync="sync_$nickname"

    local allow_empty_commit=""
    local message_commit="Sync $nickname"
    local do_edit=""
    while getopts "hm:e" arg; do
        case "$arg" in
            e)  local do_edit="--edit"
                local allow_empty_commit="--allow-empty"
                ;;
            m)  local message_commit="$OPTARG"
                local allow_empty_commit="--allow-empty"
                ;;
            h)  die_sync 0 ;;
            *)  die_sync 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    while true; do
        Git checkout main 1>&2 && Git pull 1>&2 || exit
        if git branch | grep -qv "^$branch_sync$"; then
            Git checkout -b "$branch_sync" 1>&2 || exit
            trap "Git checkout --force main 1>&2 && Git branch --delete --force \"$branch_sync\" 1>&2" EXIT
            local dir_work="$dir_repo/$here/$nickname"
            rm -rf "$dir_work" && cp -R . "$dir_work" || exit
            local x=0
            if [ -n "$(git status --short)" -o -n "$allow_empty_commit" ]; then
                Git add --all 1>&2 && Git commit "--message=\"$message\"" $do_edit $allow_empty_commit 1>&2
                local x=$?
            else
                echo "This work directory is already up to date at the parentship." 1>&2
                break
            fi
            Git checkout --force main 1>&2
            test $x != 0 && exit $x
        fi

        (
            Git checkout -b to_push 1>&2 || exit
            trap "Git checkout --force main && Git branch --delete --force to_push" EXIT
            Git merge "$branch_sync" 1>&2 || exit
            Git push --porcelain origin to_push:main 2>&1 \
                | awk -F'\t' '!/^remote:/{print > "/dev/stderr"}
                              ($1 == "!" && /to_push/ && /main/){exit 123}'
        ) && break
        local x=$?

        if [ "$x" = "123" ]; then
            cat 1>&2 <<UPLOAD
The upload of the $nickname work directory failed. This may be because the
parentship's main branch has been modified while preparing this update.
I will wait a few seconds and try again.
UPLOAD
            sleep 5
        else
            exit "$x"
        fi
    done
}


function here() {
    init
    echo $here
}


function ship() {
    init
    echo $dir_repo
}


function die_generic() {
    cat 1>&2 <<USAGE
Usage: $0 command [OPTIONS] ARGS
       $0 -h
       $0 -v

Description: dws is the Dumb Work Space. You use it to carry your work across
the various workstations you have to use. Do this by defining _spaces_ on each
workstation, which are directories recursively saved to the _mothership_. This
is a Git repository that is kept in sync with the spaces on every workstation,
possibly over Github.

Commands:

    list, ls     List the spaces, possibly on all workstations.
    add          Add a new space.
    clone        Clone a space from another workstation.
    remove, rm   Remove a local space.
    sync         Synchronize the current space with the mothership.
    here         Report the name of this workstation as you set it up.
    ship         Report the mothership directory, so you may fiddle with it
                 and re-arrange its synchronization at your convenience.

Without any command, dws tries to sync if the current directory was previously
added. Otherwise, it adds the current directory.

Requirement: having a remote Git repository (on Github, Gitlab, Sourcehut, or
any SSH server you can access) that you can use as mothership.
USAGE
    exit $1
}


# What do we do?
if [ -z "$1" ]; then
    add_or_sync
else
    cmd="$1"
    shift
    case "$cmd" in
        ls)        list ;;
        list)      list ;;
        add)       add ;;
        clone)     clone ;;
        rm)        remove ;;
        remove)    remove ;;
        del)       remove ;;
        delete)    remove ;;
        sync)      sync ;;
        here)      here ;;
        ship)      ship ;;
        -h)        die_generic 0 ;;
        -v)        echo $VERSION ;;
        *)
            echo "Unknown command: [$cmd]" 1>&2
            die_generic 1
            ;;
    esac
fi
